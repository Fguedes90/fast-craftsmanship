# Modelagem de Dados com Pydantic 2.0+ para ROP

## Introdução

Pydantic 2.0+ oferece uma maneira robusta e performática de modelar dados com validação em tempo de execução, perfeitamente adequada para uso com Railway-Oriented Programming (ROP).

## Instalação

```bash
pip install "pydantic>=2.0"
```

## Modelo Base Imutável

Primeiro, vamos criar um modelo base que todas as nossas classes podem herdar, garantindo imutabilidade por padrão:

```python
from pydantic import BaseModel, ConfigDict
from typing import TypeVar, Type
from expression import Result, Ok, Error

T = TypeVar('T', bound='ImmutableModel')

class ImmutableModel(BaseModel):
    """Modelo base imutável para todos os modelos Pydantic."""
    model_config = ConfigDict(frozen=True)
    
    @classmethod
    def create(cls: Type[T], **data) -> Result[T, str]:
        """
        Factory method que retorna um Result contendo o modelo ou erro.
        
        Exemplo:
            result = User.create(name="Alice", email="alice@example.com")
            match result:
                case Ok(user):
                    print(f"Usuário criado: {user.name}")
                case Error(msg):
                    print(f"Erro: {msg}")
        """
        try:
            instance = cls(**data)
            return Ok(instance)
        except Exception as e:
            return Error(str(e))
```

## Usando o Modelo Base

### Modelos Simples

```python
from datetime import datetime
from typing import List, Optional

class User(ImmutableModel):
    id: int
    name: str
    email: str
    created_at: datetime
    tags: List[str] = []
    profile_url: Optional[str] = None

# Criando uma instância usando o factory method
result = User.create(
    id=1,
    name="Alice",
    email="alice@example.com",
    created_at=datetime.now(),
    tags=["admin"]
)

# O modelo é imutável por padrão
# user.name = "Bob"  # Raises FrozenInstanceError
```

### Modelos com Validadores

```python
from pydantic import EmailStr, model_validator
from decimal import Decimal

class Order(ImmutableModel):
    items: List[str]
    total: Decimal
    customer_email: EmailStr
    
    @model_validator(mode='after')
    def validate_total(self) -> 'Order':
        if len(self.items) == 0 and self.total > 0:
            raise ValueError("Cannot have total > 0 with no items")
        return self

# O método create já lida com os erros de validação
result = Order.create(
    items=["item1", "item2"],
    total=Decimal("100.50"),
    customer_email="customer@example.com"
)
```

## Composição de Modelos

```python
class Address(ImmutableModel):
    street: str
    city: str
    country: str

class Item(ImmutableModel):
    name: str
    price: Decimal
    quantity: int

class CompleteOrder(ImmutableModel):
    id: int
    customer: User
    shipping_address: Address
    items: List[Item]
    
    @property
    def total(self) -> Decimal:
        return sum(item.price * item.quantity for item in self.items)
```

## Pipeline ROP com Modelos Imutáveis

```python
from expression import pipeline
from typing import Dict, Any

def validate_order_data(data: Dict[Any, Any]) -> Result[CompleteOrder, str]:
    return CompleteOrder.create(**data)

def process_order(order: CompleteOrder) -> Result[str, str]:
    if order.total > 1000:
        return Error("Ordem excede limite máximo")
    return Ok(f"Ordem processada: {order.id}")

def send_confirmation(message: str) -> Result[str, str]:
    return Ok(f"Confirmação enviada: {message}")

# Pipeline completo
order_pipeline = pipeline(
    validate_order_data,
    process_order,
    send_confirmation
)

# Exemplo de uso
order_data = {
    "id": 1,
    "customer": {
        "id": 1,
        "name": "Alice",
        "email": "alice@example.com",
        "created_at": datetime.now()
    },
    "shipping_address": {
        "street": "Rua Principal",
        "city": "São Paulo",
        "country": "Brasil"
    },
    "items": [
        {"name": "Item 1", "price": Decimal("100.00"), "quantity": 2},
        {"name": "Item 2", "price": Decimal("50.00"), "quantity": 1}
    ]
}

result = order_pipeline(order_data)
```

## Melhores Práticas

1. **Use o Modelo Base**
   - Herde de `ImmutableModel` para todos os seus modelos
   - Utilize o método `create` para instanciar modelos de forma segura
   - Aproveite o tratamento de erros embutido

2. **Validação Rigorosa**
   - Adicione validadores customizados quando necessário
   - Use tipos específicos do Pydantic (EmailStr, HttpUrl, etc.)
   - Mantenha as validações no nível do modelo

3. **Composição de Modelos**
   - Use modelos aninhados para estruturas complexas
   - Mantenha a imutabilidade em todos os níveis
   - Aproveite as properties para cálculos derivados

4. **Integração com ROP**
   - Use o método `create` em conjunto com pipeline
   - Mantenha a consistência no tratamento de erros
   - Combine validações do Pydantic com lógica de negócios

## Exemplo de Uso Avançado

```python
from datetime import date
from typing import Dict, Any

class AgeValidator(ImmutableModel):
    birth_date: date
    
    @model_validator(mode='after')
    def validate_age(self) -> 'AgeValidator':
        today = date.today()
        age = (
            today.year - self.birth_date.year -
            ((today.month, today.day) < (self.birth_date.month, self.birth_date.day))
        )
        if age < 18:
            raise ValueError("Must be at least 18 years old")
        return self

class AdvancedUser(ImmutableModel):
    name: str
    email: EmailStr
    birth_date: date
    preferences: Dict[str, Any]
    
    @model_validator(mode='after')
    def validate_user(self) -> 'AdvancedUser':
        # Valida idade usando o validador dedicado
        AgeValidator(birth_date=self.birth_date)
        return self

# O método create lida com todas as validações
result = AdvancedUser.create(
    name="Alice",
    email="alice@example.com",
    birth_date=date(1990, 1, 1),
    preferences={"theme": "dark", "notifications": True}
)
```

Esta abordagem com um modelo base imutável simplifica a criação de modelos, garante consistência e reduz a duplicação de código em todo o projeto.