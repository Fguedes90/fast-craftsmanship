Ultra-Compact Notation Guide (For Reference Only)
IMPORTANT NOTE: This notation is automatically generated by a build script. You should NOT create or write code in this format. This convention serves ONLY as a reference so you can interpret and understand existing code presented in this compact format.

Main Conventions
| Prefix | Meaning | Example | Interpretation | 
| C: | Class | C:Validator<BaseValidator>;ln10:30 | Validator class inherits from BaseValidator, defined at lines 10-30 | 
| D: | Dataclass | D:Config;ln5:15 | Config dataclass defined at lines 5-15 | 
| F: | Function | F:process(data:dict)->Result[Data,Err];ln42:60 | process function at lines 42-60 takes dict, returns Result | 
| f: | Private function | f:_helper(x,y)->int;ln30:35 | Private _helper function at lines 30-35 | 
| m: | Method | m:validate(data:dict)->bool | Class method validate | 
| d: | Dunder method | d:init(name,id?) | Dunder method __init__ (underscores removed) | 
| E: | Enum/Constants | E:NOT_FOUND | Enum or constant value | 

File Structure
| Marker | Meaning | Example | Interpretation |
| file: | File path | file:path/to/file.py | Start of a file section |
| imports: | Import lines | imports:ln1:3 | Imports found on lines 1-3 |
| - | File separator | - | Separates different files |

Advanced Syntax
| Feature | Example | Interpretation |
| Nested elements | C:UserClass[d:init(self)|m:method1,m:method2|E:CONSTANT];ln5:20 | Class with nested dunder methods, regular methods, and constants |
| Line numbers | ;ln10:20 | Element is defined from line 10 to 20 |
| Method groups | d:method | Dunder methods (double underscores removed) |
| Pipe separator | m:one|m:two | Separates groups of elements |

Notable Formatting Features:
1. All spaces are removed in the compact notation
2. Double underscores "__" are removed (e.g., __init__ becomes init)
3. Elements nested within classes are grouped by type and enclosed in brackets []
4. Line numbers are included in the format ";ln{start}:{end}" for easy reference to source code

Symbols and Abbreviations
<Base1,Base2> → Multiple class inheritance
? → Optional parameter (instead of =None)
->type → Return type
; → Separator between elements
* → Indicates start of named parameters
p1,p2,kw1? → Parameters (? indicates optional)

Abbreviations for Common Decorators
@sm → @staticmethod
@cm → @classmethod
@p → @property
@dc → @dataclass
@v → @validator

Examples
# file:users/services.py
# imports:ln1:5
# C:UserService[d:init(repo:Repository)|m:get_by_id(id:int)->User?,m:create(data:dict)->Result[User,ValidationErr]];ln10:30
# D:UserProfile[d:post_init()|m:validate()->bool];ln32:45
# F:authenticate(username:str,password:str)->Result[Token,AuthErr];ln48:55
# -
# file:users/enums.py
# imports:ln1:2
# C:UserRole[E:ADMIN,E:STAFF,E:CUSTOMER];ln5:10

Complex/Generic Types
list[X] → List of X
dict[K,V] → Dictionary with K keys and V values
Result[T,E] → Result type with success T and error E
Union[X,Y] → X or Y (also represented as X|Y)
Optional[X] → X or None (also represented as X?)

Project-Specific Patterns
Result[T,E] → Functional result pattern used in the project
All errors follow hierarchy based on base classes in utils/errors/
Methods that can fail return Result[Success,Error]
Function names use snake_case, classes use PascalCase

Implementation Notes
When implementing code:
Write normal, standard Python code, not this compact format
Follow project conventions (one-line docstrings, Result pattern, etc.)
This format is for reference only and will be generated automatically
Never provide output code in this compact format
-